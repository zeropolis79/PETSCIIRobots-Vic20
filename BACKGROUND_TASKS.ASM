BACKGROUND_TASKS:
	LDA	REDRAW_WINDOW
	CMP	#1
	BNE	UNIT_AI
	LDA	BGTIMER1
	CMP	#1
	BNE	UNIT_AI
	LDA	#0
	STA	REDRAW_WINDOW
	JSR	DRAW_MAP_WINDOW
UNIT_AI:
	;Now check to see if it is time to run background tasks
	LDA	BGTIMER1
	CMP	#1
	BEQ	AI000
	RTS
AI000:	LDA	#0
	STA	BGTIMER1	;RESET BACKGROUND TIMER
	;INC	$83C0	;-TROUBLESHOOTING
	LDX	#$FF
	STA	UNIT
AILP:	INC	UNIT		;ALL AI routines must JMP back to here at the end.
	LDX	UNIT
	CPX	#64			;END OF UNITS
	BNE	AI001
	RTS			;RETURN CONTROL TO MAIN PROGRAM
AI001:	LDA	UNIT_TYPE,X
	CMP	#0			;Does unit exist?
	BNE	AI002
	JMP	AILP
AI002:	;Unit found to exist, now check it's timer.
	;unit code won't run until timer hits zero.
	LDA	UNIT_TIMER_A,X
	CMP	#0
	BEQ	AI003
	DEC	UNIT_TIMER_A,X		;Decrease timer by one.
	JMP	AILP
AI003:	;Unit exists and timer has triggered
	;The unit type determines which AI routine is run.
	LDA	UNIT_TYPE,X
	CMP	#24			;MAX DIFFERENT UNIT TYPES IN CHART
	BCS	AILP			;ABORT IF GREATER
	TAY
	LDA	AI_ROUTINE_CHART_L,Y
	STA	AI004+1
	LDA	AI_ROUTINE_CHART_H,Y
	STA	AI004+2
AI004:	JMP	$0000	;***self modifying code used here***

AI_ROUTINE_CHART_L:
	!BYTE	<DUMMY_ROUTINE		;UNIT TYPE 00	;non-existent unit
	!BYTE	<DUMMY_ROUTINE		;UNIT TYPE 01	;player unit - can't use
	!BYTE	<LEFT_RIGHT_DROID	;UNIT TYPE 02
	!BYTE	<UP_DOWN_DROID		;UNIT TYPE 03
	!BYTE	<HOVER_ATTACK		;UNIT TYPE 04
	!BYTE	<WATER_DROID		;UNIT TYPE 05
	!BYTE	<TIME_BOMB		;UNIT TYPE 06
	!BYTE	<TRANSPORTER_PAD	;UNIT TYPE 07
	!BYTE	<DEAD_ROBOT		;UNIT TYPE 08
	!BYTE	<EVILBOT		;UNIT TYPE 09 
	!BYTE	<AI_DOOR		;UNIT TYPE 10
	!BYTE	<SMALL_EXPLOSION	;UNIT TYPE 11
	!BYTE	<PISTOL_FIRE_UP		;UNIT TYPE 12
	!BYTE	<PISTOL_FIRE_DOWN	;UNIT TYPE 13
	!BYTE	<PISTOL_FIRE_LEFT	;UNIT TYPE 14
	!BYTE	<PISTOL_FIRE_RIGHT	;UNIT TYPE 15
	!BYTE	<TRASH_COMPACTOR	;UNIT TYPE 16
	!BYTE	<UP_DOWN_ROLLERBOT	;UNIT TYPE 17
	!BYTE	<LEFT_RIGHT_ROLLERBOT	;UNIT TYPE 18
	!BYTE	<ELEVATOR		;UNIT TYPE 19
	!BYTE	<MAGNET			;UNIT TYPE 20
	!BYTE	<MAGNETIZED_ROBOT	;UNIT TYPE 21
	!BYTE	<WATER_RAFT_LR		;UNIT TYPE 22
	!BYTE	<DEMATERIALIZE		;UNIT TYPE 23

AI_ROUTINE_CHART_H:
	!BYTE	>DUMMY_ROUTINE		;UNIT TYPE 00	;non-existent unit
	!BYTE	>DUMMY_ROUTINE		;UNIT TYPE 01	;player unit - can't use
	!BYTE	>LEFT_RIGHT_DROID	;UNIT TYPE 02
	!BYTE	>UP_DOWN_DROID		;UNIT TYPE 03
	!BYTE	>HOVER_ATTACK		;UNIT TYPE 04
	!BYTE	>WATER_DROID		;UNIT TYPE 05
	!BYTE	>TIME_BOMB		;UNIT TYPE 06
	!BYTE	>TRANSPORTER_PAD	;UNIT TYPE 07
	!BYTE	>DEAD_ROBOT		;UNIT TYPE 08
	!BYTE	>EVILBOT		;UNIT TYPE 09
	!BYTE	>AI_DOOR		;UNIT TYPE 10
	!BYTE	>SMALL_EXPLOSION	;UNIT TYPE 11
	!BYTE	>PISTOL_FIRE_UP		;UNIT TYPE 12
	!BYTE	>PISTOL_FIRE_DOWN	;UNIT TYPE 13
	!BYTE	>PISTOL_FIRE_LEFT	;UNIT TYPE 14
	!BYTE	>PISTOL_FIRE_RIGHT	;UNIT TYPE 15
	!BYTE	>TRASH_COMPACTOR	;UNIT TYPE 16
	!BYTE	>UP_DOWN_ROLLERBOT	;UNIT TYPE 17
	!BYTE	>LEFT_RIGHT_ROLLERBOT	;UNIT TYPE 18
	!BYTE	>ELEVATOR		;UNIT TYPE 19
	!BYTE	>MAGNET			;UNIT TYPE 20
	!BYTE	>MAGNETIZED_ROBOT	;UNIT TYPE 21
	!BYTE	>WATER_RAFT_LR		;UNIT TYPE 22
	!BYTE	>DEMATERIALIZE		;UNIT TYPE 23

;Dummy routine does nothing, but I need it for development.
DUMMY_ROUTINE:
	JMP	AILP

WATER_RAFT_LR:
	LDA	#0
	;First check which direction raft is moving.
	LDX	UNIT
	LDA	UNIT_A,X
	CMP	#1
	BEQ	RAFT_RIGHT
	JMP	RAFT_LEFT
RAFT_RIGHT:
	JSR	RAFT_DELETE
	;Check to see if player is on raft
	LDA	UNIT_LOC_X,X	;raft
	CMP	UNIT_LOC_X	;player
	BNE	WARF05
	LDA	UNIT_LOC_Y,X	;raft
	CMP	UNIT_LOC_Y	;player
	BNE	WARF05
	INC	UNIT_LOC_X	;player
	INC	UNIT_LOC_X,X	;raft
	JSR	RAFT_PLOT
	JSR	CACULATE_AND_REDRAW
	JMP	WARF5B
WARF05:	INC	UNIT_LOC_X,X	;raft
	JSR	RAFT_PLOT
	;Now check if it has reached its destination
	JSR	CHECK_FOR_WINDOW_REDRAW
WARF5B:	LDX	UNIT
	LDA	UNIT_LOC_X,X
	CMP	UNIT_C,X	
	BEQ	WARF06
	LDA	#6
	STA	UNIT_TIMER_A,X
	JMP	AILP
WARF06:	LDA	#100
	STA	UNIT_TIMER_A,X
	LDA	#0
	STA	UNIT_A,X
	JMP	AILP

RAFT_LEFT:
	JSR	RAFT_DELETE
	;Check to see if player is on raft
	LDA	UNIT_LOC_X,X	;raft
	CMP	UNIT_LOC_X	;player
	BNE	WARF07
	LDA	UNIT_LOC_Y,X	;raft
	CMP	UNIT_LOC_Y	;player
	BNE	WARF07
	DEC	UNIT_LOC_X	;player
	DEC	UNIT_LOC_X,X	;raft
	JSR	RAFT_PLOT
	JSR	CACULATE_AND_REDRAW
	JMP	WARF7B
WARF07:	DEC	UNIT_LOC_X,X	;raft
	JSR	RAFT_PLOT
	;Now check if it has reached its destination
	JSR	CHECK_FOR_WINDOW_REDRAW
WARF7B:	LDX	UNIT
	;Now check if it has reached its destination
	LDA	UNIT_LOC_X,X
	CMP	UNIT_B,X	
	BEQ	WARF08
	LDA	#6
	STA	UNIT_TIMER_A,X
	JMP	AILP
WARF08:	LDA	#100
	STA	UNIT_TIMER_A,X
	LDA	#1
	STA	UNIT_A,X
	JMP	AILP

RAFT_DELETE:
	LDA	UNIT_LOC_X,X
	STA	MAP_X
	LDA	UNIT_LOC_Y,X
	STA	MAP_Y
	LDA	#204	;WATER TILE
	STA	TILE
	JSR 	PLOT_TILE_TO_MAP
	RTS

RAFT_PLOT:
	LDA	UNIT_LOC_X,X
	STA	MAP_X
	LDA	UNIT_LOC_Y,X
	STA	MAP_Y
	LDA	#242	;RAFT TILE
	STA	TILE
	JSR 	PLOT_TILE_TO_MAP
	RTS


MAGNETIZED_ROBOT:
	LDA	#%00000001
	STA	MOVE_TYPE
	JSR	GENERATE_RANDOM_NUMBER
	LDA	RANDOM
	AND	#%00000011
	CMP	#00
	BEQ	MAGRO1
	CMP	#01
	BEQ	MAGRO2
	CMP	#02
	BEQ	MAGRO3
	CMP	#03
	BEQ	MAGRO4
MAGRO1:	JSR	REQUEST_WALK_UP
	JMP	MAGR10
MAGRO2:	JSR	REQUEST_WALK_DOWN
	JMP	MAGR10
MAGRO3:	JSR	REQUEST_WALK_LEFT
	JMP	MAGR10
MAGRO4:	JSR	REQUEST_WALK_RIGHT
MAGR10:	JSR	CHECK_FOR_WINDOW_REDRAW
	LDX	UNIT
	LDA	#10
	STA	UNIT_TIMER_A,X
	DEC	UNIT_TIMER_B,X
	LDA	UNIT_TIMER_B,X
	CMP	#0
	BNE	MAGR11
	LDA	UNIT_D,X
	STA	UNIT_TYPE,X
MAGR11:	JMP	AILP

GENERATE_RANDOM_NUMBER:
 	LDA	RANDOM
	BEQ 	DOEOR ;added this
	ASL
	BCC	NOEOR
DOEOR:	EOR	#$1D
NOEOR:	STA	RANDOM
	RTS

MAGNET:	
	;First let's take care of the timers.  This unit runs
	;every cycle so that it can detect contact with another
	;unit.  But it still needs to count down to terminate
	;So, it uses two timers for a 16-bit value.
	LDX	UNIT
	DEC	UNIT_TIMER_B,X
	LDA	UNIT_TIMER_B,X
	CMP	#0
	BNE	MAGN1
	DEC	UNIT_A,X
	LDA	UNIT_A,X
	CMP	#0
	BNE	MAGN1
	;Both timers have reached zero, time to deactivate.
MAGN0:	LDX	UNIT
	LDA	#0
	STA	UNIT_TYPE,X
	STA	MAGNET_ACT
	JMP	AILP
MAGN1:	;Now let's see if another units walks on the magnet.
	LDA	UNIT_LOC_X,X
	STA	MAP_X
	LDA	UNIT_LOC_Y,X
	STA	MAP_Y
	JSR	CHECK_FOR_UNIT
	LDA	UNIT_FIND
	CMP	#255	;no unit found
	BEQ	MAGN2
	CMP	#0	;player unit
	BEQ	MAGN3
	JMP	MAGN4
MAGN2:	JMP	AILP
MAGN3:	INC	INV_MAGNET
	JSR	DISPLAY_ITEM
	JMP	MAGN0
MAGN4:	;Collision with robot detected.
	LDA	#4		;HAYWIRE SOUND
	JSR	PLAY_SOUND	;SOUND PLAY
	LDX	UNIT_FIND
	LDA	UNIT_TYPE,X
	STA	UNIT_D,X	;make backup of unit type
	LDA	#21	;Crazy robot AI
	STA	UNIT_TYPE,X
	LDA	#60
	STA	UNIT_TIMER_B,X
	LDX	UNIT
	JMP	MAGN0

DEAD_ROBOT:
	LDX	UNIT
	LDA	#0
	STA	UNIT_TYPE,X
	JMP	AILP

UP_DOWN_ROLLERBOT:
	LDX	UNIT
	LDA	#7
	STA	UNIT_TIMER_A,X
	JSR	ROLLERBOT_ANIMATE
	LDX	UNIT
	LDA	UNIT_A,X		;GET DIRECTION
	CMP	#1	;0=UP 1=DOWN
	BEQ	UDR01
	LDA	#%00000001
	STA	MOVE_TYPE
	JSR	REQUEST_WALK_UP
	LDA	MOVE_RESULT
	CMP	#1
	BEQ	UDR02
	LDA	#1
	LDX	UNIT
	STA	UNIT_A,X	;CHANGE DIRECTION
	JSR	ROLLERBOT_FIRE_DETECT
	JSR	CHECK_FOR_WINDOW_REDRAW
	JMP	AILP
UDR01:	LDA	#%00000001
	STA	MOVE_TYPE
	JSR	REQUEST_WALK_DOWN
	LDA	MOVE_RESULT
	CMP	#1
	BEQ	UDR02
	LDA	#0
	LDX	UNIT
	STA	UNIT_A,X	;CHANGE DIRECTION
UDR02:	JSR	ROLLERBOT_FIRE_DETECT
	JSR	CHECK_FOR_WINDOW_REDRAW
	JMP	AILP

LEFT_RIGHT_ROLLERBOT:
	LDX	UNIT
	LDA	#7
	STA	UNIT_TIMER_A,X
	JSR	ROLLERBOT_ANIMATE
	LDX	UNIT
	LDA	UNIT_A,X		;GET DIRECTION
	CMP	#1	;0=LEFT 1=RIGHT
	BEQ	LRR01
	LDA	#%00000001
	STA	MOVE_TYPE
	JSR	REQUEST_WALK_LEFT
	LDA	MOVE_RESULT
	CMP	#1
	BEQ	LRR02
	LDA	#1
	LDX	UNIT
	STA	UNIT_A,X	;CHANGE DIRECTION
	JSR	ROLLERBOT_FIRE_DETECT
	JSR	CHECK_FOR_WINDOW_REDRAW
	JMP	AILP
LRR01:	LDA	#%00000001
	STA	MOVE_TYPE
	JSR	REQUEST_WALK_RIGHT
	LDA	MOVE_RESULT
	CMP	#1
	BEQ	LRR02
	LDA	#0
	LDX	UNIT
	STA	UNIT_A,X	;CHANGE DIRECTION
LRR02:	JSR	ROLLERBOT_FIRE_DETECT
	JSR	CHECK_FOR_WINDOW_REDRAW
	JMP	AILP

ROLLERBOT_FIRE_DETECT:
	LDA	UNIT_LOC_X,X
	STA	TEMP_A
	LDA	UNIT_LOC_Y,X
	STA	TEMP_B
	;See if we're lined up vertically
	LDA	UNIT_LOC_Y,X	;robot
	CMP	UNIT_LOC_Y	;player
	BNE	RFDE2
	JMP	ROLLERBOT_FIRE_LR
RFDE2:	;See if we're lined up horizontally
	LDA	UNIT_LOC_X,X	;robot
	CMP	UNIT_LOC_X	;player
	BNE	RFDE3
	JMP	ROLLERBOT_FIRE_UD
RFDE3:	RTS

ROLLERBOT_FIRE_LR:
	LDA	UNIT_LOC_X,X
	CMP	UNIT_LOC_X
	BCC	RBFLR2
	JMP	ROLLERBOT_FIRE_LEFT
RBFLR2:	JMP	ROLLERBOT_FIRE_RIGHT

ROLLERBOT_FIRE_LEFT:
	;Check to see if distance is less than 5
	LDA	UNIT_LOC_X,X	;robot
	SEC
	SBC	UNIT_LOC_X	;player
	CMP	#6
	BCC	RFL0
	RTS	
RFL0:	LDX	#28
RFL1:	LDA	UNIT_TYPE,X
	CMP	#0
	BEQ	RFL2
	INX
	CPX	#32
	BNE	RFL1
	RTS
RFL2:	LDA	#14	;pistol fire left AI
	STA	UNIT_TYPE,X
	LDA	#245	;tile for horizontal weapons fire
	JMP	ROLLERBOT_AFTER_FIRE
	
ROLLERBOT_FIRE_RIGHT:
	;Check to see if distance is less than 5
	LDA	UNIT_LOC_X	;player
	SEC
	SBC	UNIT_LOC_X,X	;robot
	CMP	#6
	BCC	RFR0
	RTS	
RFR0:	LDX	#28
RFR1:	LDA	UNIT_TYPE,X
	CMP	#0
	BEQ	RFR2
	INX
	CPX	#32
	BNE	RFR1
	RTS
RFR2:	LDA	#15	;pistol fire RIGHT AI
	STA	UNIT_TYPE,X
	LDA	#245	;tile for horizontal weapons fire
	JMP	ROLLERBOT_AFTER_FIRE
	RTS

ROLLERBOT_FIRE_UD:
	LDA	UNIT_LOC_Y,X
	CMP	UNIT_LOC_Y
	BCC	RBFUD2
	JMP	ROLLERBOT_FIRE_UP
RBFUD2:	JMP	ROLLERBOT_FIRE_DOWN

ROLLERBOT_FIRE_UP:
	;Check to see if distance is less than 5
	LDA	UNIT_LOC_Y,X	;robot
	SEC
	SBC	UNIT_LOC_Y	;player
	CMP	#4
	BCC	RFU0
	RTS	
RFU0:	LDX	#28
RFU1:	LDA	UNIT_TYPE,X
	CMP	#0
	BEQ	RFU2
	INX
	CPX	#32
	BNE	RFU1
	RTS
RFU2:	LDA	#12	;pistol fire UP AI
	STA	UNIT_TYPE,X
	LDA	#244	;tile for horizontal weapons fire
	JMP	ROLLERBOT_AFTER_FIRE
	
ROLLERBOT_FIRE_DOWN:
	;Check to see if distance is less than 5
	LDA	UNIT_LOC_Y	;player
	SEC
	SBC	UNIT_LOC_Y,X	;robot
	CMP	#4
	BCC	RFD0
	RTS	
RFD0:	LDX	#28
RFD1:	LDA	UNIT_TYPE,X
	CMP	#0
	BEQ	RFD2
	INX
	CPX	#32
	BNE	RFD1
	RTS
RFD2:	LDA	#13	;pistol fire DOWN AI
	STA	UNIT_TYPE,X
	LDA	#244	;tile for horizontal weapons fire
	JMP	ROLLERBOT_AFTER_FIRE

ROLLERBOT_AFTER_FIRE:
	STA	UNIT_TILE,X
	LDA	#5		;travel distance.
	STA	UNIT_A,X
	LDA	#0		;weapon-type = pistol
	STA	UNIT_B,X
	STA	UNIT_TIMER_A,X
	LDA	TEMP_A
	STA	UNIT_LOC_X,X
	LDA	TEMP_B
	STA	UNIT_LOC_Y,X
	LDA	#9		;PISTOL SOUND
	JSR	PLAY_SOUND	;SOUND PLAY
	RTS

ROLLERBOT_ANIMATE:
	LDA	UNIT_TIMER_B,X
	CMP	#0
	BEQ	ROLAN2
	DEC	UNIT_TIMER_B,X
	RTS
ROLAN2:	LDA	#3
	STA	UNIT_TIMER_B,X	;RESET ANIMATE TIMER
	LDA	UNIT_TILE,X
	CMP	#164
	BNE	ROLAN1
	LDA	#165		;ROLLERBOT TILE
	STA	UNIT_TILE,X
	JSR	CHECK_FOR_WINDOW_REDRAW
	RTS
ROLAN1:	LDA	#164		;ROLLERBOT TILE
	STA	UNIT_TILE,X
	JSR	CHECK_FOR_WINDOW_REDRAW
	RTS



;UNIT_A: 0=always active	1=only active when all robots are dead
;UNIT_B: 0=completes level 1=send to coordinates
;UNIT_C: X-coordinate
;UNIT_D: Y-coordinate

;The "DEMATERIALIZE" part of this AI routine has to be in the main 
;source for each individual computer, because the screen effects
;are created uniquely for each one.

TRANSPORTER_PAD:
	;first determine if the player is standing here
	LDX	UNIT
	LDA	UNIT_LOC_X,X
	CMP	UNIT_LOC_X
	BNE	TRP01
	LDA	UNIT_LOC_Y,X
	CMP	UNIT_LOC_Y
	BNE	TRP01
	JMP	TRANS_PLAYER_PRESENT	
TRP01:	;player not present
	LDA	UNIT_A,X
	CMP	#1
	BEQ	TRP02
	JMP	TRANS_ACTIVE
TRP02:	;test if all robots are dead
	LDX	#1
TRP03:	LDA	UNIT_TYPE,X
	CMP	#0
	BNE	TRP04
	INX
	CPX	#28
	BNE	TRP03
	LDX	UNIT
	LDA	#0
	STA	UNIT_A,X	;make unit active
TRP04:	LDX	UNIT
	LDA	#30
	STA	UNIT_TIMER_A,X
	JMP	AILP		

TRANS_PLAYER_PRESENT:
	LDX	UNIT
	LDA	UNIT_A,X
	CMP	#0	;unit active
	BEQ	TRPL1
	LDA	#<MSG_TRANS1
	STA	$FB
	LDA	#>MSG_TRANS1
	STA	$FC
	JSR	PRINT_INFO
	LDA	#11		;error-SOUND
	JSR	PLAY_SOUND	;SOUND PLAY
	LDX	UNIT
	LDA	#100
	STA	UNIT_TIMER_A,X
	JMP	AILP
TRPL1:	;start transport process
	LDA	#23	;Convert to different AI
	STA	UNIT_TYPE,X
	LDA	#5
	STA	UNIT_TIMER_A,X
	LDA	#0
	STA	UNIT_TIMER_B,X
	JMP	AILP

TRANS_ACTIVE:
	LDA	UNIT_TIMER_B,X
	CMP	#1
	BEQ	TRAC1
	LDA	#1
	STA	UNIT_TIMER_B,X
	LDA	#30
	STA	TILE
	JMP	TRAC2
TRAC1:	LDA	#0
	STA	UNIT_TIMER_B,X
	LDA	#31
	STA	TILE
TRAC2:	LDA	UNIT_LOC_X,X
	STA	MAP_X
	LDA	UNIT_LOC_Y,X
	STA	MAP_Y
	JSR	PLOT_TILE_TO_MAP
	JSR	CHECK_FOR_WINDOW_REDRAW
	LDA	#30
	STA	UNIT_TIMER_A,X
	JMP	AILP

TIME_BOMB:
	LDX	UNIT
	LDA	UNIT_A,X
	CMP	#0
	BNE	TB01
	JMP	BIG_EXP_PHASE1
TB01:	CMP	#1
	BNE	TB02
	JMP	BIG_EXP_PHASE2
TB02:	JMP	AILP

;This is the large explosion used by the time-bomb
;and plasma gun, and maybe others.  This is the first
;phase of the explosion, which stores the tiles to
;a buffer and then changes each tile to an explosion.
BIG_EXP_PHASE1:
	LDA	BIG_EXP_ACT
	CMP	#0	;Check that no other explosion active.
	BEQ	BEX001
	LDX	UNIT
	LDA	#10
	STA	UNIT_TIMER_A,X
	JMP	AILP	;wait for existing explosion to finish.
BEX001:
	LDA	#1		;Set flag so no other explosions
	STA	BIG_EXP_ACT	;can begin until this one ends.
	STA	SCREEN_SHAKE
	LDA	#0	;explosion-sound
	JSR	PLAY_SOUND	;SOUND PLAY
	JSR	BEX_PART1	;check center piece for unit
	JSR	BEXCEN		;check center piece for unit
	JSR	BEX1_NORTH
	JSR	BEX1_SOUTH
	JSR	BEX1_EAST
	JSR	BEX1_WEST
	JSR	BEX1_NE
	JSR	BEX1_NW
	JSR	BEX1_SE
	JSR	BEX1_SW
	LDX	UNIT
	LDA	#246		;explosion tile
	STA	UNIT_TILE,X
	LDA	#1		;move to next phase of explosion.
	STA	UNIT_A,X
	LDA	#12
	STA	UNIT_TIMER_A,X
	LDA	#1
	STA	REDRAW_WINDOW
	JMP	AILP

;There are 8 separate subroutines for the large explosion
;with each one handling a specific outward direction of motion.
;The "unit" itself changes tiles to an explosion, so we don't
;need to mess with the center tile.
BEX1_NORTH:
	JSR	BEX_PART1
	;first tile
	DEC	MAP_Y
	JSR	BEX_PART2
	BEQ	BEX1N1
	RTS
BEX1N1:	LDA	TILE
	STA	EXP_BUFFER+0
	JSR	BEX_PART3
	;second tile
	DEC	MAP_Y
JSR	BEX_PART2
	BEQ	BEX1N2
	RTS
BEX1N2:	LDA	TILE
	STA	EXP_BUFFER+1
	JSR	BEX_PART3
	RTS

BEX1_SOUTH:
	JSR	BEX_PART1
	;first tile
	INC	MAP_Y
	JSR	BEX_PART2
	BEQ	BEX1S1
	RTS
BEX1S1:	LDA	TILE
	STA	EXP_BUFFER+2
	JSR	BEX_PART3
	;second tile
	INC	MAP_Y
	JSR	BEX_PART2
	BEQ	BEX1S2
	RTS
BEX1S2:	LDA	TILE
	STA	EXP_BUFFER+3
	JSR	BEX_PART3
	RTS

BEX1_EAST:
	JSR	BEX_PART1
	;first tile
	INC	MAP_X
	JSR	BEX_PART2
	BEQ	BEX1E1
	RTS
BEX1E1:	LDA	TILE
	STA	EXP_BUFFER+4
	JSR	BEX_PART3
	;second tile
	INC	MAP_X
	JSR	BEX_PART2
	BEQ	BEX1E2
	RTS
BEX1E2:	LDA	TILE
	STA	EXP_BUFFER+5
	JSR	BEX_PART3
	RTS

BEX1_WEST:
	JSR	BEX_PART1
	;first tile
	DEC	MAP_X
	JSR	BEX_PART2
	BEQ	BEX1W1
	RTS
BEX1W1:	LDA	TILE
	STA	EXP_BUFFER+6
	JSR	BEX_PART3
	;second tile
	DEC	MAP_X
	JSR	BEX_PART2
	BEQ	BEX1W2
	RTS
BEX1W2:	LDA	TILE
	STA	EXP_BUFFER+7
	JSR	BEX_PART3
	RTS

BEX1_NE:
	JSR	BEX_PART1
	;first tile
	INC	MAP_X
	DEC	MAP_Y
	JSR	BEX_PART2
	BEQ	BEX1NE1
	RTS
BEX1NE1:LDA	TILE
	STA	EXP_BUFFER+8
	JSR	BEX_PART3
	;second tile
	INC	MAP_X
	DEC	MAP_Y
	JSR	BEX_PART2
	BEQ	BEX1NE2
	RTS
BEX1NE2:LDA	TILE
	STA	EXP_BUFFER+9
	JSR	BEX_PART3
	RTS

BEX1_NW:
	JSR	BEX_PART1
	;first tile
	DEC	MAP_X
	DEC	MAP_Y
	JSR	BEX_PART2
	BEQ	BEX1NW1
	RTS
BEX1NW1:LDA	TILE
	STA	EXP_BUFFER+10
	JSR	BEX_PART3
	;second tile
	DEC	MAP_X
	DEC	MAP_Y
	JSR	BEX_PART2
	BEQ	BEX1NW2
	RTS
BEX1NW2:LDA	TILE
	STA	EXP_BUFFER+11
	JSR	BEX_PART3
	RTS

BEX1_SE:
	JSR	BEX_PART1
	;first tile
	INC	MAP_X
	INC	MAP_Y
	JSR	BEX_PART2
	BEQ	BEX1SE1
	RTS
BEX1SE1:LDA	TILE
	STA	EXP_BUFFER+12
	JSR	BEX_PART3
	;second tile
	INC	MAP_X
	INC	MAP_Y
	JSR	BEX_PART2
	BEQ	BEX1SE2
	RTS
BEX1SE2:LDA	TILE
	STA	EXP_BUFFER+13
	JSR	BEX_PART3
	RTS

BEX1_SW:
	JSR	BEX_PART1
	;first tile
	DEC	MAP_X
	INC	MAP_Y
	JSR	BEX_PART2
	BEQ	BEX1SW1
	RTS
BEX1SW1:LDA	TILE
	STA	EXP_BUFFER+14
	JSR	BEX_PART3
	;second tile
	DEC	MAP_X
	INC	MAP_Y
	JSR	BEX_PART2
	BEQ	BEX1SW2
	RTS
BEX1SW2:LDA	TILE
	STA	EXP_BUFFER+15
	JSR	BEX_PART3
	RTS

BEX_PART1:
	LDX	UNIT
	LDA	UNIT_LOC_X,X
	STA	MAP_X
	LDA	UNIT_LOC_Y,X
	STA	MAP_Y
	RTS

BEX_PART2:
	JSR	GET_TILE_FROM_MAP
	LDY	TILE
	LDA	TILE_ATTRIB,Y
	AND	#%00010000	;can see through tile?
	CMP	#%00010000
	RTS

BEX_PART3:
	LDA	#246
	LDY	#0
	STA	($FD),Y
BEXCEN:	JSR	CHECK_FOR_UNIT
	LDA	UNIT_FIND
	CMP	#255
	BEQ	EPT2	
	LDA	#11
	STA	TEMP_A
	JSR	INFLICT_DAMAGE
EPT2:	RTS

BIG_EXP_PHASE2:
	;Do the center tile first.
	JSR	BEX_PART1
	JSR	GET_TILE_FROM_MAP
	LDA	#246
	STA	($FD),Y
	LDA	TILE
	STA	TEMP_A
	JSR	RESTORE_TILE	
	;tile #0 north 1
	JSR	BEX_PART1
	DEC	MAP_Y
	LDA	EXP_BUFFER+0
	STA	TEMP_A
	JSR	RESTORE_TILE
	;tile #1 north 2
	DEC	MAP_Y
	LDA	EXP_BUFFER+1
	STA	TEMP_A
	JSR	RESTORE_TILE
	;tile #2 south 1
	JSR	BEX_PART1
	INC	MAP_Y
	LDA	EXP_BUFFER+2
	STA	TEMP_A
	JSR	RESTORE_TILE	
	;tile #3 south 2
	INC	MAP_Y
	LDA	EXP_BUFFER+3
	STA	TEMP_A
	JSR	RESTORE_TILE
	;tile #4 east 1
	JSR	BEX_PART1
	INC	MAP_X
	LDA	EXP_BUFFER+4
	STA	TEMP_A
	JSR	RESTORE_TILE
	;tile #5 east 2
	INC	MAP_X
	LDA	EXP_BUFFER+5
	STA	TEMP_A
	JSR	RESTORE_TILE
	;tile #6 west 1
	JSR	BEX_PART1
	DEC	MAP_X
	LDA	EXP_BUFFER+6
	STA	TEMP_A
	JSR	RESTORE_TILE
	;tile #7 west 2
	DEC	MAP_X
	LDA	EXP_BUFFER+7
	STA	TEMP_A
	JSR	RESTORE_TILE
	;tile #8 northeast 1
	JSR	BEX_PART1
	DEC	MAP_Y
	INC	MAP_X
	LDA	EXP_BUFFER+8
	STA	TEMP_A
	JSR	RESTORE_TILE
	;tile #9 northeast 2
	DEC	MAP_Y
	INC	MAP_X
	LDA	EXP_BUFFER+9
	STA	TEMP_A
	JSR	RESTORE_TILE
	;tile #10 northwest 1
	JSR	BEX_PART1
	DEC	MAP_Y
	DEC	MAP_X
	LDA	EXP_BUFFER+10
	STA	TEMP_A
	JSR	RESTORE_TILE
	;tile #11 northwest 2
	DEC	MAP_Y
	DEC	MAP_X
	LDA	EXP_BUFFER+11
	STA	TEMP_A
	JSR	RESTORE_TILE
	;tile #12 southeast 1
	JSR	BEX_PART1
	INC	MAP_Y
	INC	MAP_X
	LDA	EXP_BUFFER+12
	STA	TEMP_A
	JSR	RESTORE_TILE
	;tile #13 southeast 2
	INC	MAP_Y
	INC	MAP_X
	LDA	EXP_BUFFER+13
	STA	TEMP_A
	JSR	RESTORE_TILE
	;tile #14 southwest 1
	JSR	BEX_PART1
	INC	MAP_Y
	DEC	MAP_X
	LDA	EXP_BUFFER+14
	STA	TEMP_A
	JSR	RESTORE_TILE
	;tile #15 southwest 2
	INC	MAP_Y
	DEC	MAP_X
	LDA	EXP_BUFFER+15
	STA	TEMP_A
	JSR	RESTORE_TILE
	LDA	#1
	STA	REDRAW_WINDOW
	LDX	UNIT
	LDA	#0
	STA	UNIT_TYPE,X	;Deactivate this AI
	STA	BIG_EXP_ACT
	STA	SCREEN_SHAKE
	JMP	AILP

RESTORE_TILE:
	JSR	GET_TILE_FROM_MAP
	LDA	TILE
	CMP	#246
	BEQ	REST0
	RTS
	
REST0:	LDY	TEMP_A
	CPY	#131	;Cannister tile
	BEQ	REST3
	LDA	TILE_ATTRIB,Y
	AND	#%00001000	;can it be destroyed?
	CMP	#%00001000
	BNE	REST2
	LDA	DESTRUCT_PATH,Y
	LDY	#0
	STA	($FD),Y
	RTS
REST2:	LDA	TEMP_A
	LDY	#0
	STA	($FD),Y
	RTS
REST3:	;What to do if we encounter an explosive cannister
	LDA	#135	;Blown cannister
	LDY	#0
	STA	($FD),Y
	LDX	#28	;Start of weapons units
REST4:	LDA	UNIT_TYPE,X
	CMP	#0
	BEQ	REST5
	INX
	CPX	#32
	BNE	REST4
	RTS	;no slots available right now, abort.
REST5:	LDA	#6	;bomb AI
	STA	UNIT_TYPE,X
	LDA	#131	;Cannister tile
	STA	UNIT_TILE,X
	LDA	MAP_X
	STA	UNIT_LOC_X,X
	LDA	MAP_Y
	STA	UNIT_LOC_Y,X
	LDA	#10		;How long until exposion?
	STA	UNIT_TIMER_A,X
	LDA	#0
	STA	UNIT_A,X
	RTS

TRASH_COMPACTOR:
	LDX	UNIT	
	LDA	UNIT_A,X
	CMP	#0	;OPEN
	BNE	TRS01
	JMP	TC_OPEN_STATE
TRS01:	CMP	#1	;MID-CLOSING STATE
	BNE	TRS02
	JMP	TC_MID_CLOSING
TRS02:	CMP	#2	;CLOSED STATE
	BNE	TRS03
	JMP	TC_CLOSED_STATE
TRS03:	CMP	#3	;MID-OPENING STATE
	BNE	TRS04
	JMP	TC_MID_OPENING
TRS04:	JMP	AILP	;should never get here.	
	
TC_OPEN_STATE:
	LDA	UNIT_LOC_X,X
	STA	MAP_X
	LDA	UNIT_LOC_Y,X
	STA	MAP_Y
	JSR	GET_TILE_FROM_MAP
	CMP	#148	;Usual tile for trash compactor danger zone
	BNE	TRS15
TRS10:	INY	
	LDA	($FD),Y
	CMP	#148	;Usual tile for trash compactor danger zone
	BNE	TRS15
	LDA	#20
	STA	UNIT_TIMER_A,X
	;now check for units in the compactor
	LDA	UNIT_LOC_X,X
	STA	MAP_X
	LDA	UNIT_LOC_Y,X
	STA	MAP_Y
	JSR	CHECK_FOR_UNIT
	LDA	UNIT_FIND
	CMP	#255
	BNE	TRS15
	JMP	AILP	;Nothing found, do nothing.
TRS15:	;Object has been detected in TC, start closing.
	LDA	#146
	STA	TCPIECE1
	LDA	#147
	STA	TCPIECE2
	LDA	#150
	STA	TCPIECE3
	LDA	#151
	STA	TCPIECE4
	JSR	DRAW_TRASH_COMPACTOR
	INC	UNIT_A,X
	LDA	#10
	STA	UNIT_TIMER_A,X	
	LDA	#14		;door sound
	JSR	PLAY_SOUND	;SOUND PLAY
	JMP	AILP

TC_MID_CLOSING:
	LDA	#152
	STA	TCPIECE1
	LDA	#153
	STA	TCPIECE2
	LDA	#156
	STA	TCPIECE3
	LDA	#157
	STA	TCPIECE4
	JSR	DRAW_TRASH_COMPACTOR
	INC	UNIT_A,X
	LDA	#50
	STA	UNIT_TIMER_A,X
	;Now check for any live units in the compactor
	LDA	UNIT_LOC_X,X
	STA	MAP_X
	LDA	UNIT_LOC_Y,X
	STA	MAP_Y
	JSR	CHECK_FOR_UNIT
	LDA	UNIT_FIND
	CMP	#255
	BNE	TCMC1
	INC	MAP_X	;check second tile
	JSR	CHECK_FOR_UNIT
	LDA	UNIT_FIND
	CMP	#255
	BNE	TCMC1
	JMP	AILP
TCMC1:	;Found unit in compactor, kill it.
	LDA	#<MSG_TERMINATED
	STA	$FB
	LDA	#>MSG_TERMINATED
	STA	$FC
	JSR	PRINT_INFO
	LDA	#0	;EXPLOSION sound
	JSR	PLAY_SOUND	;SOUND PLAY
	LDX	UNIT_FIND
	LDA	#0
	STA	UNIT_TYPE,X
	STA	UNIT_HEALTH,X
	LDX	#28	;start of weapons
TCMC2:	LDA	UNIT_TYPE,X
	CMP	#0
	BEQ	TCMC3
	INX
	CPX	#32
	BNE	TCMC2
	JSR	CHECK_FOR_WINDOW_REDRAW	
	JMP	AILP
TCMC3:	LDA	#11	;SMALL EXPLOSION
	STA	UNIT_TYPE,X
	LDA	#248	;first tile for explosion
	STA	UNIT_TILE,X
	LDY	UNIT
	LDA	UNIT_LOC_X,Y
	STA	UNIT_LOC_X,X
	LDA	UNIT_LOC_Y,Y
	STA	UNIT_LOC_Y,X
	LDA	UNIT_FIND
	CMP	#0	;is it the player?
	BNE	TCMC4
	LDA	#10
	STA	BORDER
TCMC4:	JSR	CHECK_FOR_WINDOW_REDRAW	
	JMP	AILP

TC_CLOSED_STATE:
	LDA	#146
	STA	TCPIECE1
	LDA	#147
	STA	TCPIECE2
	LDA	#150
	STA	TCPIECE3
	LDA	#151
	STA	TCPIECE4
	JSR	DRAW_TRASH_COMPACTOR
	INC	UNIT_A,X
	LDA	#10
	STA	UNIT_TIMER_A,X	
	JMP	AILP

TC_MID_OPENING:
	LDA	#144
	STA	TCPIECE1
	LDA	#145
	STA	TCPIECE2
	LDA	#148
	STA	TCPIECE3
	LDA	#148
	STA	TCPIECE4
	JSR	DRAW_TRASH_COMPACTOR	
	LDA	#0
	STA	UNIT_A,X
	LDA	#20
	STA	UNIT_TIMER_A,X
	LDA	#14		;door sound
	JSR	PLAY_SOUND	;SOUND PLAY	
	JMP	AILP

DRAW_TRASH_COMPACTOR:
	LDA	UNIT_LOC_Y,X
	STA	MAP_Y
	DEC	MAP_Y	;start one tile above
	LDA	UNIT_LOC_X,X
	STA	MAP_X
	LDA	TCPIECE1
	STA	TILE
	JSR	PLOT_TILE_TO_MAP
	INY
	LDA	TCPIECE2
	STA	($FD),Y	
	TYA
	CLC
	ADC	#127
	TAY
	LDA	TCPIECE3
	STA	($FD),Y
	LDA	TCPIECE4
	INY	
	STA	($FD),Y
	JSR	CHECK_FOR_WINDOW_REDRAW	
	RTS
TCPIECE1:	!BYTE 00
TCPIECE2:	!BYTE 00
TCPIECE3:	!BYTE 00
TCPIECE4:	!BYTE 00

WATER_DROID:
	;first rotate the tiles
	LDX	UNIT
	INC	UNIT_TILE,X
	LDA	UNIT_TILE,X
	CMP	#143
	BNE	WD01
	LDA	#140
	STA	UNIT_TILE,X
WD01:	DEC	UNIT_A,X
	LDA	UNIT_A,X
	CMP	#0
	BEQ	WD02
	JSR	CHECK_FOR_WINDOW_REDRAW	
	JMP	AILP
WD02:	;kill unit after countdown reaches zero. 
	LDA	#08	;Dead robot type
	STA	UNIT_TYPE,X
	LDA	#255
	STA	UNIT_TIMER_A,X
	LDA	#115	;dead robot tile
	STA	UNIT_TILE,X
	JSR	CHECK_FOR_WINDOW_REDRAW	
	JMP	AILP

PISTOL_FIRE_UP:
	;Check if it has reached limits.
	LDX	UNIT	
	LDA	UNIT_A,X
	CMP	#0
	BNE	PFU02
	;if it has reached max range, then it vanishes.
	JSR	DEACTIVATE_WEAPON
	JMP	PFU05
PFU02:	DEC	UNIT_LOC_Y,X	;move it up one.
	JMP	PISTOL_AI_COMMON
PFU05:	JSR	CHECK_FOR_WINDOW_REDRAW	
	JMP	AILP

PISTOL_FIRE_DOWN:
	;Check if it has reached limits.
	LDX	UNIT	
	LDA	UNIT_A,X
	CMP	#0
	BNE	PFD02
	;if it has reached max range, then it vanishes.
	JSR	DEACTIVATE_WEAPON
	JMP	PFD05
PFD02:	INC	UNIT_LOC_Y,X	;move it down one.
	JMP	PISTOL_AI_COMMON
PFD05:	JSR	CHECK_FOR_WINDOW_REDRAW	
	JMP	AILP

PISTOL_FIRE_LEFT:
	;Check if it has reached limits.
	LDX	UNIT	
	LDA	UNIT_A,X
	CMP	#0
	BNE	PFL02
	;if it has reached max range, then it vanishes.
	JSR	DEACTIVATE_WEAPON
	JMP	PFL05
PFL02:	DEC	UNIT_LOC_X,X	;move it left one.
	JMP	PISTOL_AI_COMMON
PFL05:	JSR	CHECK_FOR_WINDOW_REDRAW	
	JMP	AILP

PISTOL_FIRE_RIGHT:
	;Check if it has reached limits.
	LDX	UNIT	
	LDA	UNIT_A,X
	CMP	#0
	BNE	PFR02
	;if it has reached max range, then it vanishes.
	JSR	DEACTIVATE_WEAPON
	JMP	PFR05
PFR02:	INC	UNIT_LOC_X,X	;move it right one.
	JMP	PISTOL_AI_COMMON
PFR05:	JSR	CHECK_FOR_WINDOW_REDRAW	
	JMP	AILP

DEACTIVATE_WEAPON:
	LDA	#0
	STA	UNIT_TYPE,X
	LDA	UNIT_B,X
	CMP	#1
	BNE	DEW1
	LDA	#0
	STA	UNIT_B,X
	STA	PLASMA_ACT
DEW1:	RTS

PISTOL_AI_COMMON:
	LDA	UNIT_B,X	;is it pistol or plasma?
	CMP	#0
	BEQ	PAIC02
	JMP	PLASMA_AI_COMMON
PAIC02:	DEC	UNIT_A,X	;reduce range by one
	;Now check what map object it is on.
	LDA	UNIT_LOC_X,X
	STA	MAP_X
	LDA	UNIT_LOC_Y,X
	STA	MAP_Y
	JSR	GET_TILE_FROM_MAP
	LDY	TILE
	CMP	#131	;explosive cannister
	BNE	PAIC04
	;hit an explosive cannister
	LDA	#135	;Blown cannister
	LDY	#0
	STA	($FD),Y
	LDX	UNIT
	LDA	#6	;bomb AI
	STA	UNIT_TYPE,X
	LDA	#131	;Cannister tile
	STA	UNIT_TILE,X
	LDA	MAP_X
	STA	UNIT_LOC_X,X
	LDA	MAP_Y
	STA	UNIT_LOC_Y,X
	LDA	#5		;How long until exposion?
	STA	UNIT_TIMER_A,X
	LDA	#0
	STA	UNIT_A,X
	JMP	AILP
PAIC04:	LDA	TILE_ATTRIB,Y
	;AND 	#%00000010	;Check, can hover on this?
	;CMP	#%00000010
	AND 	#%00010000	;can see through tile?
	CMP	#%00010000
	BEQ	PAIC05
	;Hit object that can't pass through, convert to explosion
	LDA	#11	;SMALL EXPLOSION
	STA	UNIT_TYPE,X
	LDA	#248	;first tile for explosion
	STA	UNIT_TILE,X
	JSR	CHECK_FOR_WINDOW_REDRAW	
	JMP	AILP
PAIC05:	;check if it encountered a robot/human
	JSR	CHECK_FOR_UNIT
	LDA	UNIT_FIND
	CMP	#255	;NO UNIT ENCOUNTERED.
	BNE	PAIC06
	JSR	CHECK_FOR_WINDOW_REDRAW	
	JMP	AILP
PAIC06:	;struck a robot/human
	LDX	UNIT
	LDA	#11	;SMALL EXPLOSION
	STA	UNIT_TYPE,X
	LDA	#248	;first tile for explosion
	STA	UNIT_TILE,X
	LDA	#1	;set damage for pistol
	STA	TEMP_A	
	JSR	INFLICT_DAMAGE
	JSR	ALTER_AI
	JSR	CHECK_FOR_WINDOW_REDRAW	
	JMP	AILP

PLASMA_AI_COMMON:
	DEC	UNIT_A,X	;reduce range by one
	;find what tile we are over
	LDA	UNIT_LOC_X,X
	STA	MAP_X
	LDA	UNIT_LOC_Y,X
	STA	MAP_Y
	JSR	GET_TILE_FROM_MAP
	LDY	TILE
	CPY	#131	;cannister tile
	BEQ	PLAI11
	LDA	TILE_ATTRIB,Y
	AND 	#%00010000	;can see through tile?
	CMP	#%00010000
	BEQ	PLAI05
	JMP	PLAI11
PLAI05:	;check if it encountered a human/robot
	JSR	CHECK_FOR_UNIT
	LDA	UNIT_FIND
	CMP	#255	;NO UNIT ENCOUNTERED.
	BNE	PLAI11
PLAI10:	;no impacts detected:
	JSR	CHECK_FOR_WINDOW_REDRAW	
	JMP	AILP
PLAI11:	;impact detected. convert to explosion
	LDX	UNIT
	LDA	#6	;bomb AI
	STA	UNIT_TYPE,X
	LDA	#1		;How long until exposion?
	STA	UNIT_TIMER_A,X
	LDA	#0
	STA	UNIT_A,X
	STA	PLASMA_ACT
	JSR	CHECK_FOR_WINDOW_REDRAW	
	JMP	AILP

;This routine checks to see if the robot being shot
;is a hoverbot, if so it will alter it's AI to attack 
;mode.
ALTER_AI:
	LDX	UNIT_FIND
	LDA	UNIT_TYPE,X
	CMP	#2	;hoverbot left/right
	BEQ	ATKMOD
	CMP	#3	;hoverbot UP/DOWN
	BEQ	ATKMOD
	RTS
ATKMOD:	LDA	#4	;Attack AI
	STA	UNIT_TYPE,X
	RTS
	

;This routine will inflict damage on whatever is defined in
;UNIT_FIND in the amount set in TEMP_A.  If the damage is more
;than the health of that unit, it will delete the unit.
INFLICT_DAMAGE:
	LDX	UNIT_FIND
	LDA	UNIT_HEALTH,X
	SEC
	SBC	TEMP_A
	STA	UNIT_HEALTH,X
	BCC	UNIT_DEAD
	CMP	#0
	BEQ	UNIT_DEAD
	CPX	#0	;IS IT THE PLAYER?
	BNE	IND1
	JSR	DISPLAY_PLAYER_HEALTH
	LDA	#10
	STA	BORDER
IND1:	RTS
UNIT_DEAD:
	LDA	#0
	STA	UNIT_HEALTH,X
	CPX	#0	;Is it the player that is dead?
	BEQ	UD01
	LDA	#08	;Dead robot type
	CMP	UNIT_TYPE,X	;is it a dead robot already?
	BEQ	UD0A
	STA	UNIT_TYPE,X
	LDA	#255
	STA	UNIT_TIMER_A,X
	LDA	#115	;dead robot tile
	STA	UNIT_TILE,X
UD0A:	RTS
UD01:	LDA	#0
	STA	UNIT_TYPE,X
	JSR	DISPLAY_PLAYER_HEALTH
	LDA	#10
	STA	BORDER
	RTS
	
SMALL_EXPLOSION:
	LDA	#0
	STA	UNIT_TIMER_A,X
	INC	UNIT_TILE,X
	LDA	UNIT_TILE,X
	CMP	#252
	BEQ	SEXP1
	JSR	CHECK_FOR_WINDOW_REDRAW
	JMP	AILP
SEXP1:	LDA	#0
	STA	UNIT_TYPE,X
	JSR	CHECK_FOR_WINDOW_REDRAW	
	JMP	AILP		
	
HOVER_ATTACK:
	LDX	UNIT
	LDA	#0
	STA	UNIT_TIMER_B,X
	JSR	HOVERBOT_ANIMATE
	LDA	#7
	STA	UNIT_TIMER_A,X
	LDA	#%00000010	;HOVER
	STA	MOVE_TYPE
	;CHECK FOR HORIZONTAL MOVEMENT
	LDA	UNIT_LOC_X,X
	CMP	UNIT_LOC_X
	BEQ	HOAT13
	BCC	HOAT12
	JSR	REQUEST_WALK_LEFT
	JMP	HOAT13
HOAT12:	JSR	REQUEST_WALK_RIGHT
HOAT13:	;NOW CHECK FOR VERITCAL MOVEMENT
	LDA	UNIT_LOC_Y,X
	CMP	UNIT_LOC_Y
	BEQ	HOAT20
	BCC	HOAT14
	JSR	REQUEST_WALK_UP
	JMP	HOAT20
HOAT14:	JSR	REQUEST_WALK_DOWN	
HOAT20:	JSR	ROBOT_ATTACK_RANGE
	LDA	PROX_DETECT
	CMP	#1	;1=Robot next to player 0=not
	BNE	HOAT21	
	LDA	#1	;amount of damage it will inflict
	STA	TEMP_A	
	LDA	#0	;unit to inflict damage on.
	STA	UNIT_FIND
	JSR	INFLICT_DAMAGE
	JSR	CREATE_PLAYER_EXPLOSION
	LDA	#07		;electric shock
	JSR	PLAY_SOUND	;SOUND PLAY
	LDX	UNIT
	LDA	#30		;rate of attack on player.
	STA	UNIT_TIMER_A,X
	;add some code here to create explosion
HOAT21:	JSR	CHECK_FOR_WINDOW_REDRAW	
	JMP	AILP

CREATE_PLAYER_EXPLOSION:
	LDX	#28
TE01:	LDA	UNIT_TYPE,X
	CMP	#0
	BEQ	TE02
	INX
	CPX	#32	;max unit for weaponsfire
	BNE	TE01	
TE02:	LDA	#11	;Small explosion AI type
	STA	UNIT_TYPE,X
	LDA	#248	;first tile for explosion
	STA	UNIT_TILE,X
	LDA	#1
	STA	UNIT_TIMER_A,X
	LDA	UNIT_LOC_X
	STA	UNIT_LOC_X,X
	LDA	UNIT_LOC_Y
	STA	UNIT_LOC_Y,X
	RTS	

EVILBOT:
	LDX	UNIT
	LDA	#5
	STA	UNIT_TIMER_A,X
	;first animate evilbot
	LDA	UNIT_TILE,X
	CMP	#100
	BNE	EVIL1
	INC	UNIT_TILE,X
	JMP	EVIL10
EVIL1:	CMP	#101
	BNE	EVIL2
	INC	UNIT_TILE,X
	JMP	EVIL10
EVIL2:	CMP	#102
	BNE	EVIL3
	INC	UNIT_TILE,X
	JMP	EVIL10
EVIL3:	LDA	#100
	STA	UNIT_TILE,X
EVIL10:	;now figure out movement
	LDA	UNIT_TIMER_B,X
	CMP	#0
	BEQ	EVIL11
	DEC	UNIT_TIMER_B,X
	JSR	CHECK_FOR_WINDOW_REDRAW
	JMP	AILP
EVIL11:	LDA	#1	;Reset timer B
	STA	UNIT_TIMER_B,X
	LDA	#%00000001	;WALK
	STA	MOVE_TYPE
	;CHECK FOR HORIZONTAL MOVEMENT
	LDA	UNIT_LOC_X,X
	CMP	UNIT_LOC_X
	BEQ	EVIL13
	BCC	EVIL12
	JSR	REQUEST_WALK_LEFT
	JMP	EVIL13
EVIL12:	JSR	REQUEST_WALK_RIGHT
EVIL13:	;NOW CHECK FOR VERITCAL MOVEMENT
	LDA	UNIT_LOC_Y,X
	CMP	UNIT_LOC_Y
	BEQ	EVIL20
	BCC	EVIL14
	JSR	REQUEST_WALK_UP
	JMP	EVIL20
EVIL14:	JSR	REQUEST_WALK_DOWN	
EVIL20:	JSR	ROBOT_ATTACK_RANGE
	LDA	PROX_DETECT
	CMP	#1	;1=Robot next to player 0=not
	BNE	EVIL21	
	LDA	#5	;amount of damage it will inflict
	STA	TEMP_A	
	LDA	#0	;unit to inflict damage on.
	STA	UNIT_FIND
	JSR	INFLICT_DAMAGE
	JSR	CREATE_PLAYER_EXPLOSION
	LDA	#07		;electric shock sound
	JSR	PLAY_SOUND	;SOUND PLAY
	LDX	UNIT
	LDA	#15		;rate of attack on player.
	STA	UNIT_TIMER_A,X
EVIL21:	JSR	CHECK_FOR_WINDOW_REDRAW	
	JMP	AILP

;This routine handles automatic sliding doors.
;UNIT_B register means:
;0=opening-A 1=opening-B 2=OPEN 3=closing-A 4=closing-B 5-CLOSED
AI_DOOR:
	LDX	UNIT
	LDA	UNIT_B,X
	CMP	#06	;make sure number is in bounds
	BCS	DOORA
	TAY
	LDA	AIDB_L,Y
	STA	DOORJ+1
	LDA	AIDB_H,Y
	STA	DOORJ+2
DOORJ:	JMP	$0000	;self modifying code
DOORA:	JMP	AILP	;-SHOULD NEVER NEED TO HAPPEN
AIDB_L:	
	!BYTE	<DOOR_OPEN_A
	!BYTE	<DOOR_OPEN_B
	!BYTE	<DOOR_OPEN_FULL
	!BYTE	<DOOR_CLOSE_A
	!BYTE	<DOOR_CLOSE_B
	!BYTE	<DOOR_CLOSE_FULL
AIDB_H:	
	!BYTE	>DOOR_OPEN_A
	!BYTE	>DOOR_OPEN_B
	!BYTE	>DOOR_OPEN_FULL
	!BYTE	>DOOR_CLOSE_A
	!BYTE	>DOOR_CLOSE_B
	!BYTE	>DOOR_CLOSE_FULL

DOOR_OPEN_A:
	LDA	UNIT_A,X
	CMP	#1
	BEQ	DOA1
	;HORIZONTAL DOOR
	LDA	#88
	STA	DOORPIECE1
	LDA	#89
	STA	DOORPIECE2
	LDA	#86
	STA	DOORPIECE3
	JSR	DRAW_HORIZONTAL_DOOR
	JMP	DOA2
DOA1:	;VERTICAL DOOR
	LDA	#70
	STA	DOORPIECE1
	LDA	#74
	STA	DOORPIECE2
	LDA	#78
	STA	DOORPIECE3
	JSR	DRAW_VERTICAL_DOOR
DOA2:	LDY	UNIT
	LDA	#1
	STA	UNIT_B,X
	LDA	#5
	STA	UNIT_TIMER_A,X
	JSR	CHECK_FOR_WINDOW_REDRAW	
	JMP	AILP

DOOR_OPEN_B:
	LDA	UNIT_A,X
	CMP	#1
	BEQ	DOB1
	;HORIZONTAL DOOR
	LDA	#17
	STA	DOORPIECE1
	LDA	#09
	STA	DOORPIECE2
	LDA	#91
	STA	DOORPIECE3
	JSR	DRAW_HORIZONTAL_DOOR
	JMP	DOB2
DOB1:	;VERTICAL DOOR
	LDA	#27
	STA	DOORPIECE1
	LDA	#09
	STA	DOORPIECE2
	LDA	#15
	STA	DOORPIECE3
	JSR	DRAW_VERTICAL_DOOR
DOB2:	LDX	UNIT
	LDA	#2
	STA	UNIT_B,X
	LDA	#30
	STA	UNIT_TIMER_A,X
	JSR	CHECK_FOR_WINDOW_REDRAW	
	JMP	AILP
DOOR_OPEN_FULL:
	LDX	UNIT
	JSR	DOOR_CHECK_PROXIMITY	
	LDA	PROX_DETECT
	CMP	#1
	BNE	DOF1
	LDA	#30
	STA	UNIT_TIMER_B,X	;RESET TIMER
	JMP	AILP
DOF1:	;if nobody near door, lets close it.
	;check for object in the way first.
	LDA	UNIT_LOC_X,X
	STA	MAP_X
	LDA	UNIT_LOC_Y,X
	STA	MAP_Y
	JSR	GET_TILE_FROM_MAP
	LDA	TILE
	CMP	#09	;FLOOR-TILE
	BEQ	DOFB
	;SOMETHING IN THE WAY, ABORT
	LDA	#35
	STA	UNIT_TIMER_A,X
	JMP	AILP
DOFB:	LDA	#14		;DOOR-SOUND
	JSR	PLAY_SOUND	;SOUND PLAY
	LDX	UNIT
	LDA	UNIT_A,X
	CMP	#1
	BEQ	DOF2
	;HORIZONTAL_DOOR
	LDA	#88
	STA	DOORPIECE1
	LDA	#89
	STA	DOORPIECE2
	LDA	#86
	STA	DOORPIECE3
	JSR	DRAW_HORIZONTAL_DOOR
	JMP	DOF3
DOF2:	;VERTICAL DOOR
	LDA	#70
	STA	DOORPIECE1
	LDA	#74
	STA	DOORPIECE2
	LDA	#78
	STA	DOORPIECE3
	JSR	DRAW_VERTICAL_DOOR
DOF3:	LDY	UNIT
	LDA	#3
	STA	UNIT_B,X
	LDA	#5
	STA	UNIT_TIMER_A,X
	JSR	CHECK_FOR_WINDOW_REDRAW	
	JMP	AILP

DOOR_CLOSE_A:
	LDA	UNIT_A,X
	CMP	#1
	BEQ	DCA2
	;HORIZONTAL DOOR
	LDA	#84
	STA	DOORPIECE1
	LDA	#85
	STA	DOORPIECE2
	LDA	#86
	STA	DOORPIECE3
	JSR	DRAW_HORIZONTAL_DOOR
	JMP	DCA3
DCA2:	;VERTICAL DOOR
	LDA	#69
	STA	DOORPIECE1
	LDA	#73
	STA	DOORPIECE2
	LDA	#77
	STA	DOORPIECE3
	JSR	DRAW_VERTICAL_DOOR
DCA3:	LDY	UNIT
	LDA	#4
	STA	UNIT_B,X
	LDA	#5
	STA	UNIT_TIMER_A,X
	JSR	CHECK_FOR_WINDOW_REDRAW	
	JMP	AILP

DOOR_CLOSE_B:
	LDA	UNIT_A,X
	CMP	#1
	BEQ	DCB2
	;HORIZONTAL DOOR
	LDA	#80
	STA	DOORPIECE1
	LDA	#81
	STA	DOORPIECE2
	LDA	#82
	STA	DOORPIECE3
	JSR	DRAW_HORIZONTAL_DOOR
	JMP	DCB3
DCB2:	;VERTICAL DOOR
	LDA	#68
	STA	DOORPIECE1
	LDA	#72
	STA	DOORPIECE2
	LDA	#76
	STA	DOORPIECE3
	JSR	DRAW_VERTICAL_DOOR
DCB3:	LDY	UNIT
	LDA	#5
	STA	UNIT_B,X
	LDA	#5
	STA	UNIT_TIMER_A,X
	JSR	CHECK_FOR_WINDOW_REDRAW	
	JMP	AILP

DOOR_CLOSE_FULL:
	LDX	UNIT
	JSR	DOOR_CHECK_PROXIMITY	
	LDA	PROX_DETECT
	CMP	#0
	BNE	DCF1
DCF0:	LDA	#20
	STA	UNIT_TIMER_A,X	;RESET TIMER
	JMP	AILP
DCF1:	;if player near door, lets open it.
	;first check if locked
	LDA	UNIT_C,X	;Lock status
	CMP	#0	;UNLOCKED
	BEQ	DCFZ
	CMP	#1	;SPADE KEY
	BNE	DCFB		
	LDA	KEYS
	AND	#%00000001	;CHECK FOR SPADE KEY
	CMP	#%00000001
	BEQ	DCFZ
	JMP	DCF0
DCFB:	CMP	#2	;HEART KEY
	BNE	DCFC		
	LDA	KEYS
	AND	#%00000010	;CHECK FOR HEART KEY
	CMP	#%00000010
	BEQ	DCFZ
	JMP	DCF0
DCFC:	CMP	#3	;STAR KEY
	BNE	DCF0	;SHOULD NEVER HAPPEN	
	LDA	KEYS
	AND	#%00000100	;CHECK FOR STAR KEY
	CMP	#%00000100
	BEQ	DCFZ
	JMP	DCF0
DCFZ:	;Start open door process
	LDA	#14		;DOOR-SOUND
	JSR	PLAY_SOUND	;SOUND PLAY
	LDX	UNIT
	LDA	UNIT_A,X
	CMP	#1
	BEQ	DCF2
	;HORIZONTAL DOOR
	LDA	#84
	STA	DOORPIECE1
	LDA	#85
	STA	DOORPIECE2
	LDA	#86
	STA	DOORPIECE3
	JSR	DRAW_HORIZONTAL_DOOR
	JMP	DCF3
	;VERTICAL DOOR
DCF2:	LDA	#69
	STA	DOORPIECE1
	LDA	#73
	STA	DOORPIECE2
	LDA	#77
	STA	DOORPIECE3
	JSR	DRAW_VERTICAL_DOOR
DCF3:	LDY	UNIT
	LDA	#0
	STA	UNIT_B,X
	LDA	#5
	STA	UNIT_TIMER_A,X
	JSR	CHECK_FOR_WINDOW_REDRAW	
	JMP	AILP

DRAW_VERTICAL_DOOR:
	LDA	UNIT_LOC_Y,X
	STA	MAP_Y
	DEC	MAP_Y
	LDA	UNIT_LOC_X,X
	STA	MAP_X
	LDA	DOORPIECE1
	STA	TILE
	JSR	PLOT_TILE_TO_MAP
	LDA	$FD
	CLC
	ADC	#128
	STA	$FD
	LDA	$FE
	ADC	#$00
	STA	$FE
	LDA	DOORPIECE2
	STA	($FD),Y
	LDA	$FD
	CLC
	ADC	#128
	STA	$FD
	LDA	$FE
	ADC	#$00
	STA	$FE
	LDA	DOORPIECE3
	STA	($FD),Y	
	RTS

DRAW_HORIZONTAL_DOOR:
	LDA	UNIT_LOC_X,X
	STA	MAP_X
	DEC	MAP_X
	LDA	UNIT_LOC_Y,X
	STA	MAP_Y
	LDA	DOORPIECE1
	STA	TILE
	JSR	PLOT_TILE_TO_MAP
	INY
	LDA	DOORPIECE2
	STA	($FD),Y
	INY
	LDA	DOORPIECE3
	STA	($FD),Y
	RTS
DOORPIECE1	!BYTE	00
DOORPIECE2	!BYTE	00
DOORPIECE3	!BYTE	00

ROBOT_ATTACK_RANGE:
	;First check horizontal proximity to door
	LDA	UNIT_LOC_X,X	;ROBOT UNIT
	SEC 	;always set carry before subtraction
	SBC 	UNIT_LOC_X	;PLAYER UNIT
	BCC 	RAR1 ;if carry cleared then its negative
	JMP	RAR2
RAR1:	EOR 	#$FF ;convert two's comp back to positive
	ADC 	#$01 ;no need for CLC here, already cleared
RAR2:	CMP	#1	;1 HORIZONTAL TILE FROM PLAYER
	BCC	RAR3
	LDA	#0	;player not detected
	STA	PROX_DETECT
	RTS	
RAR3:	;Now check vertical proximity
	LDA	UNIT_LOC_Y,X	;DOOR UNIT
	SEC 	;always set carry before subtraction
	SBC 	UNIT_LOC_Y	;PLAYER UNIT
	BCC 	RAR4 ;if carry cleared then its negative
	JMP	RAR5
RAR4:	EOR 	#$FF ;convert two's comp back to positive
	ADC 	#$01 ;no need for CLC here, already cleared
RAR5:	CMP	#1	;1 VERTICAL TILE FROM PLAYER
	BCC	RAR6
	LDA	#0	;player not detected
	STA	PROX_DETECT
	RTS		
RAR6:	;PLAYER DETECTED, CHANGE DOOR MODE.
	LDA	#1
	STA	PROX_DETECT
	RTS		

DOOR_CHECK_PROXIMITY:
	;First check horizontal proximity to door
	LDA	UNIT_LOC_X,X	;DOOR UNIT
	SEC 	;always set carry before subtraction
	SBC 	UNIT_LOC_X	;PLAYER UNIT
	BCC 	PRD1 ;if carry cleared then its negative
	JMP	PRD2
PRD1:	EOR 	#$FF ;convert two's comp back to positive
	ADC 	#$01 ;no need for CLC here, already cleared
PRD2:	CMP	#2	;2 HORIZONTAL TILES FROM PLAYER
	BCC	PRD3
	LDA	#0	;player not detected
	STA	PROX_DETECT
	RTS	
PRD3:	;Now check vertical proximity
	LDA	UNIT_LOC_Y,X	;DOOR UNIT
	SEC 	;always set carry before subtraction
	SBC 	UNIT_LOC_Y	;PLAYER UNIT
	BCC 	PRD4 ;if carry cleared then its negative
	JMP	PRD5
PRD4:	EOR 	#$FF ;convert two's comp back to positive
	ADC 	#$01 ;no need for CLC here, already cleared
PRD5:	CMP	#2	;2 VERTICAL TILES FROM PLAYER
	BCC	PRD6
	LDA	#0	;player not detected
	STA	PROX_DETECT
	RTS		
PRD6:	;PLAYER DETECTED, CHANGE DOOR MODE.
	LDA	#1
	STA	PROX_DETECT
	RTS	
PROX_DETECT	!BYTE	00	;0=NO 1=YES

;This routine handles automatic sliding doors.
;UNIT_B register means:
;0=opening-A 1=opening-B 2=OPEN 3=closing-A 4=closing-B 5-CLOSED
ELEVATOR:
	LDX	UNIT
	LDA	UNIT_B,X
	CMP	#06	;make sure number is in bounds
	BCS	ELEVA
	TAY
	LDA	ELDB_L,Y
	STA	ELEVJ+1
	LDA	ELDB_H,Y
	STA	ELEVJ+2
ELEVJ:	JMP	$0000	;self modifying code
ELEVA:	JMP	AILP	;-SHOULD NEVER NEED TO HAPPEN
ELDB_L:	
	!BYTE	<ELEV_OPEN_A
	!BYTE	<ELEV_OPEN_B
	!BYTE	<ELEV_OPEN_FULL
	!BYTE	<ELEV_CLOSE_A
	!BYTE	<ELEV_CLOSE_B
	!BYTE	<ELEV_CLOSE_FULL
ELDB_H:	
	!BYTE	>ELEV_OPEN_A
	!BYTE	>ELEV_OPEN_B
	!BYTE	>ELEV_OPEN_FULL
	!BYTE	>ELEV_CLOSE_A
	!BYTE	>ELEV_CLOSE_B
	!BYTE	>ELEV_CLOSE_FULL

ELEV_OPEN_A:
	LDA	#181
	STA	DOORPIECE1
	LDA	#89
	STA	DOORPIECE2
	LDA	#173
	STA	DOORPIECE3
	JSR	DRAW_HORIZONTAL_DOOR
	LDY	UNIT
	LDA	#1
	STA	UNIT_B,X
	LDA	#5
	STA	UNIT_TIMER_A,X
	JSR	CHECK_FOR_WINDOW_REDRAW	
	JMP	AILP
	
ELEV_OPEN_B:
	LDA	#182
	STA	DOORPIECE1
	LDA	#09
	STA	DOORPIECE2
	LDA	#172
	STA	DOORPIECE3
	JSR	DRAW_HORIZONTAL_DOOR
	LDX	UNIT
	LDA	#2
	STA	UNIT_B,X
	LDA	#50
	STA	UNIT_TIMER_A,X
	JSR	CHECK_FOR_WINDOW_REDRAW	
	JMP	AILP

ELEV_OPEN_FULL:
	LDX	UNIT
EVOF1:	;CLOSE DOOR
	;check for object in the way first.
	LDA	UNIT_LOC_X,X
	STA	MAP_X
	LDA	UNIT_LOC_Y,X
	STA	MAP_Y
	JSR	GET_TILE_FROM_MAP
	LDA	TILE
	CMP	#09	;FLOOR-TILE
	BEQ	EVOF3
	;SOMETHING IN THE WAY, ABORT
EVOF2:	LDA	#35
	STA	UNIT_TIMER_A,X
	JMP	AILP
EVOF3:	;check for player or robot in the way
	JSR	CHECK_FOR_UNIT
	LDX	UNIT
	LDA	UNIT_FIND	
	CMP	#255
	BNE	EVOF2
EVOFB:	;START TO CLOSE ELEVATOR DOOR
	LDA	#14		;DOOR SOUND
	JSR	PLAY_SOUND	;SOUND PLAY
	LDX	UNIT
	LDA	#181
	STA	DOORPIECE1
	LDA	#89
	STA	DOORPIECE2
	LDA	#173
	STA	DOORPIECE3
	JSR	DRAW_HORIZONTAL_DOOR
	LDX	UNIT
	LDA	#3
	STA	UNIT_B,X
	LDA	#5
	STA	UNIT_TIMER_A,X
	JSR	CHECK_FOR_WINDOW_REDRAW	
	JMP	AILP

ELEV_CLOSE_A:
	LDA	#84
	STA	DOORPIECE1
	LDA	#85
	STA	DOORPIECE2
	LDA	#173
	STA	DOORPIECE3
	JSR	DRAW_HORIZONTAL_DOOR
	LDY	UNIT
	LDA	#4
	STA	UNIT_B,X
	LDA	#5
	STA	UNIT_TIMER_A,X
	JSR	CHECK_FOR_WINDOW_REDRAW	
	JMP	AILP

ELEV_CLOSE_B:
	LDA	#80
	STA	DOORPIECE1
	LDA	#81
	STA	DOORPIECE2
	LDA	#174
	STA	DOORPIECE3
	JSR	DRAW_HORIZONTAL_DOOR
	LDY	UNIT
	LDA	#5
	STA	UNIT_B,X
	LDA	#5
	STA	UNIT_TIMER_A,X
	JSR	CHECK_FOR_WINDOW_REDRAW
	JSR	ELEVATOR_PANEL
	JMP	AILP

ELEV_CLOSE_FULL:
	LDX	UNIT
	JSR	DOOR_CHECK_PROXIMITY	
	LDA	PROX_DETECT
	CMP	#0
	BNE	EVF1
	LDA	#20
	STA	UNIT_TIMER_A,X	;RESET TIMER
	JMP	AILP
EVF1:	;Start open door process
	LDA	#14		;DOOR SOUND
	JSR	PLAY_SOUND	;SOUND PLAY
	LDX	UNIT
	LDA	#84
	STA	DOORPIECE1
	LDA	#85
	STA	DOORPIECE2
	LDA	#173
	STA	DOORPIECE3
	JSR	DRAW_HORIZONTAL_DOOR
	LDY	UNIT
	LDA	#0
	STA	UNIT_B,X
	LDA	#5
	STA	UNIT_TIMER_A,X
	JSR	CHECK_FOR_WINDOW_REDRAW	
	JMP	AILP

ELEVATOR_PANEL:
	;Check to see if player is standing in the
	;elevator first.
	LDX	UNIT
	LDA	UNIT_LOC_X,X	;elevator X location
	CMP	UNIT_LOC_X	;player X location
	BEQ	ELPN1
	RTS
ELPN1:	LDA	UNIT_LOC_Y,X	;elevator Y location
	SEC
	SBC	#01
	CMP	UNIT_LOC_Y	;player Y location
	BEQ	ELPN2
	RTS
ELPN2:	;PLAYER DETECTED, START ELEVATOR PANEL
	LDA	#<MSG_ELEVATOR
	STA	$FB
	LDA	#>MSG_ELEVATOR
	STA	$FC
	JSR	PRINT_INFO
	LDA	#<MSG_LEVELS
	STA	$FB
	LDA	#>MSG_LEVELS
	STA	$FC
	JSR	PRINT_INFO
	JSR	ELEVATOR_SELECT
	RTS

PLOT_TILE_TO_MAP:
	LDY	#0
	LDA	MAP_Y
	CLC
	ROR
	PHP
	CLC
	ADC	#>MAP
	STA	$FE	;HIGH BYTE OF MAP SOURCE
	LDA	#$0
	PLP
	ROR
	ORA	MAP_X
	STA	$FD	;LOW BYTE OF MAP SOURCE
	LDA	TILE
	STA	($FD),Y
	RTS

;This routine will return the tile for a specific X/Y
;on the map.  You must first define MAP_X and MAP-Y.
;The result is stored in TILE.
GET_TILE_FROM_MAP:
	LDY	#0
	LDA	MAP_Y
	CLC
	ROR
	PHP
	CLC
	ADC	#>MAP
	STA	$FE	;HIGH BYTE OF MAP SOURCE
	LDA	#$0
	PLP
	ROR
	ORA	MAP_X
	STA	$FD	;LOW BYTE OF MAP SOURCE
	LDA	($FD),Y
	STA	TILE
	RTS	

;In this AI routine, the droid simply goes left until it
;hits an object, and then reverses direction and does the
;same, bouncing back and forth.
LEFT_RIGHT_DROID:
	LDX	UNIT
	JSR	HOVERBOT_ANIMATE
	LDA	#10		;reset timer to 10
	STA	UNIT_TIMER_A,X	
	LDA	UNIT_A,X		;GET DIRECTION
	CMP	#1	;0=LEFT 1=RIGHT
	BEQ	LRD01
	LDA	#%00000010
	STA	MOVE_TYPE
	JSR	REQUEST_WALK_LEFT
	LDA	MOVE_RESULT
	CMP	#1
	BEQ	LRD02
	LDA	#1
	LDX	UNIT
	STA	UNIT_A,X	;CHANGE DIRECTION
	JSR	CHECK_FOR_WINDOW_REDRAW
	JMP	AILP
LRD01:	LDA	#%00000010
	STA	MOVE_TYPE
	JSR	REQUEST_WALK_RIGHT
	LDA	MOVE_RESULT
	CMP	#1
	BEQ	LRD02
	LDA	#0
	LDX	UNIT
	STA	UNIT_A,X	;CHANGE DIRECTION
LRD02:	JSR	CHECK_FOR_WINDOW_REDRAW
	JMP	AILP

;In this AI routine, the droid simply goes UP until it
;hits an object, and then reverses direction and does the
;same, bouncing back and forth.
UP_DOWN_DROID:
	LDX	UNIT
	JSR	HOVERBOT_ANIMATE
	LDA	#10		;reset timer to 10
	STA	UNIT_TIMER_A,X	
	LDA	UNIT_A,X		;GET DIRECTION
	CMP	#1	;0=UP 1=DOWN
	BEQ	UDD01
	LDA	#%00000010
	STA	MOVE_TYPE
	JSR	REQUEST_WALK_UP
	LDA	MOVE_RESULT
	CMP	#1
	BEQ	UDD02
	LDA	#1
	LDX	UNIT
	STA	UNIT_A,X	;CHANGE DIRECTION
	JSR	CHECK_FOR_WINDOW_REDRAW
	JMP	AILP
UDD01:	LDA	#%00000010
	STA	MOVE_TYPE
	JSR	REQUEST_WALK_DOWN
	LDA	MOVE_RESULT
	CMP	#1
	BEQ	UDD02
	LDA	#0
	LDX	UNIT
	STA	UNIT_A,X	;CHANGE DIRECTION
UDD02:	JSR	CHECK_FOR_WINDOW_REDRAW
	JMP	AILP

HOVERBOT_ANIMATE:
	LDA	UNIT_TIMER_B,X
	CMP	#0
	BEQ	HOVAN2
	DEC	UNIT_TIMER_B,X
	RTS
HOVAN2:	LDA	#3
	STA	UNIT_TIMER_B,X	;RESET ANIMATE TIMER
	LDA	UNIT_TILE,X
	CMP	#98
	BNE	HOVAN1
	LDA	#99		;HOVERBOT TILE
	STA	UNIT_TILE,X
	RTS
HOVAN1:	LDA	#98		;HOVERBOT TILE
	STA	UNIT_TILE,X
	RTS
		
;The following 4 routines are used by both the player and some
;of the enemy units.  It checks to see if you can walk in a
;specific direction.  It checks for edge of map and also that
;the tile you want to walk onto can allow that.  There is a
;separate routine for hovering robots.
REQUEST_WALK_RIGHT:
	LDY	UNIT
	LDA	UNIT_LOC_X,Y
	CMP	#122
	BEQ	MGR01
	STA	MAP_X
	INC 	MAP_X
	LDA	UNIT_LOC_Y,Y
	STA	MAP_Y
	JSR	GET_TILE_FROM_MAP
	LDY	TILE
	LDA	TILE_ATTRIB,Y
	AND 	MOVE_TYPE	;Check, can walk on this tile?
	CMP	MOVE_TYPE
	BNE	MGR01
	JSR	CHECK_FOR_UNIT
	LDA	UNIT_FIND
	CMP	#255
	BNE	MGR01
	LDX	UNIT	
	INC	UNIT_LOC_X,X
	LDA	#1		;Move success
	STA	MOVE_RESULT
	RTS
MGR01:	LDA	#0		;Move fail
	STA	MOVE_RESULT
	RTS

REQUEST_WALK_LEFT:
	LDY	UNIT
	LDA	UNIT_LOC_X,Y
	CMP	#5
	BEQ	MGL01
	STA	MAP_X
	DEC 	MAP_X
	LDA	UNIT_LOC_Y,Y
	STA	MAP_Y
	JSR	GET_TILE_FROM_MAP
	LDY	TILE
	LDA	TILE_ATTRIB,Y
	AND 	MOVE_TYPE	;Check, can walk on this tile?
	CMP	MOVE_TYPE
	BNE	MGL01
	JSR	CHECK_FOR_UNIT
	LDA	UNIT_FIND
	CMP	#255
	BNE	MGL01
	LDX	UNIT	
	DEC	UNIT_LOC_X,X
	LDA	#1		;Move success
	STA	MOVE_RESULT
	RTS
MGL01:	LDA	#0		;Move fail
	STA	MOVE_RESULT
	RTS

REQUEST_WALK_DOWN:
	LDY	UNIT
	LDA	UNIT_LOC_Y,Y
	CMP	#60
	BEQ	MGD01
	STA	MAP_Y
	INC 	MAP_Y
	LDA	UNIT_LOC_X,Y
	STA	MAP_X
	JSR	GET_TILE_FROM_MAP
	LDY	TILE
	LDA	TILE_ATTRIB,Y
	AND 	MOVE_TYPE	;Check, can walk on this tile?
	CMP	MOVE_TYPE
	BNE	MGD01
	JSR	CHECK_FOR_UNIT
	LDA	UNIT_FIND
	CMP	#255
	BNE	MGD01
	LDX	UNIT	
	INC	UNIT_LOC_Y,X
LDA	#1		;Move success
	STA	MOVE_RESULT
	RTS
MGD01:	LDA	#0		;Move fail
	STA	MOVE_RESULT
	RTS

REQUEST_WALK_UP:
	LDY	UNIT
	LDA	UNIT_LOC_Y,Y
	CMP	#3
	BEQ	MGU01
	STA	MAP_Y
	DEC 	MAP_Y
	LDA	UNIT_LOC_X,Y
	STA	MAP_X
	JSR	GET_TILE_FROM_MAP
	LDY	TILE
	LDA	TILE_ATTRIB,Y
	AND 	MOVE_TYPE	;Check, can walk on this tile?
	CMP	MOVE_TYPE
	BNE	MGU01
	JSR	CHECK_FOR_UNIT
	LDA	UNIT_FIND
	CMP	#255
	BNE	MGU01
	LDX	UNIT	
	DEC	UNIT_LOC_Y,X
	LDA	#1		;Move success
	STA	MOVE_RESULT
	RTS
MGU01:	LDA	#0		;Move fail
	STA	MOVE_RESULT
	RTS

;This routine checks a specific place on the map specified
;in MAP_X and MAP_Y to see if there is a unit present at 
;that spot. If so, the unit# will be stored in UNIT_FIND
;otherwise 255 will be stored. 
CHECK_FOR_UNIT:
	LDX	#0
CFU00:	LDA	UNIT_TYPE,X
	CMP	#0
	BNE	CFU02
CFU01:	INX
	CPX	#28
	BNE	CFU00
	LDA	#255
	STA	UNIT_FIND	;no units found
	RTS
CFU02:	LDA	UNIT_LOC_X,X
	CMP	MAP_X
	BNE	CFU01
	LDA	UNIT_LOC_Y,X
	CMP	MAP_Y
	BNE	CFU01
	STX	UNIT_FIND	;unit found
	RTS

;This routine checks a specific place on the map specified
;in MAP_X and MAP_Y to see if there is a hidden unit present 
;at that spot. If so, the unit# will be stored in UNIT_FIND
;otherwise 255 will be stored. 
CHECK_FOR_HIDDEN_UNIT:
	LDX	#48
CFH00:	LDA	UNIT_TYPE,X
	CMP	#0
	BNE	CFH02
CFH01:	INX
	CPX	#64
	BNE	CFH00
	LDA	#255
	STA	UNIT_FIND	;no units found
	RTS
CFH02:	;first compare horizontal position
	LDA	UNIT_LOC_X,X
	CMP	MAP_X
	BEQ	CFH05
	BCC	CFH03
	JMP	CFH01
CFH03:	CLC
	ADC	UNIT_C,X	;add hidden unit width
	CMP	MAP_X
	BCC	CFH01	
CFH05:	;now compare vertical position
	LDA	UNIT_LOC_Y,X
	CMP	MAP_Y
	BEQ	CFH10
	BCC	CFH06
	JMP	CFH01
CFH06:	CLC
	ADC	UNIT_D,X	;add hidden unit HEIGHT
	CMP	MAP_Y
	BCC	CFH01	
CFH10:	STX	UNIT_FIND	;unit found
	RTS

;NOTES ABOUT UNIT TYPES
;----------------------
;000=no unit (does not exist)
;001=player unit
;002=hoverbot left-to-right
;003=hoverbot up-down
;004=hoverbot attack mode
;005=hoverbot chase player
;006=
;007=transporter
;008=
;009=evilbot chase player
;010=door
;011=small explosion
;012=pistol fire up
;013=pistol fire down
;014=pistol fire left
;015=pistol fire right
;016=trash compactor
;017=
;018=
;019=
;020=

;NOTES ABOUT UNIT NUMBERING SCHEME
;---------------------------------
;0 = player unit
;1-27 = enemy robots	(max 28 units)
;28-31 = weapons fire
;32-47 = doors and other units that don't have sprites (max 16 units)
;48-63 = hidden objects to be found (max 16 units)

;NOTES ABOUT DOORS.
;-------------------
;A-0=horitzonal 1=vertical
;B-0=opening-A 1=opening-B 2=OPEN / 3=closing-A 4=closing-B 5-CLOSED
;C-0=unlocked / 1=locked spade 2=locked heart 3=locked star
;D-0=automatic / 0=manual

;HIDDEN OBJECTS
;--------------
;UNIT_TYPE:128=key UNIT_A: 0=SPADE 1=HEART 2=STAR
;UNIT_TYPE:129=time bomb
;UNIT_TYPE:130=EMP
;UNIT_TYPE:131=pistol
;UNIT_TYPE:132=charged plasma gun
;UNIT_TYPE:133=medkit
;UNIT_TYPE:134=magnet

;NOTES ABOUT TRANSPORTER
;----------------------
;UNIT_A: 0=always active	1=only active when all robots are dead
;UNIT_B:	0=completes level 1=send to coordinates
;UNIT_C:	X-coordinate
;UNIT_D:	Y-coordinate

;Sound Effects
;----------------------
;0 explosion
;1 small explosion
;2 medkit
;3 emp
;4 haywire
;5 evilbot
;6 move
;7 electric shock
;8 plasma gun
;9 fire pistol
;10 item found
;11 error
;12 change weapons
;13 change items
;14 door
;15 menu beep
;16 walk
;17 sfx (short beep)
;18 sfx
